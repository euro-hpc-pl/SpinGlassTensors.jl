        - export QMps, QMpo, local_dims, Site, Sites, Tensor
        - export SparseSiteTensor, SparseVirtualTensor, IdentityQMps
        - 
        - abstract type AbstractEnvironment end
        - abstract type AbstractSparseTensor end
        - 
        - const Site = Union{Int, Rational{Int}}
        - const Sites = NTuple{N, Site} where N
        - struct SparseSiteTensor <: AbstractSparseTensor
        -     loc_exp::Vector{<:Real}
        -     projs::NTuple{N, Vector{Int}} where N
        - end
        - 
        - #TODO: potentially change name. Used in SquareStar geometry.
        - struct SparseVirtualTensor <: AbstractSparseTensor
        -     con::Matrix{<:Real}
        -     projs::NTuple{N, Vector{Int}} where N
        - end
        - 
        - const Tensor = Union{AbstractArray{Float64}, SparseSiteTensor, SparseVirtualTensor}
        - 
        - #TODO: type of sites
        - struct QMps <: AbstractTensorNetwork{Number}
        -     tensors::Dict{Site, Tensor}
        -     sites::Vector{Site}
        -     QMps(tensors::Dict{<:Site, <:Tensor}) = new(tensors, sort(collect(keys(tensors))))
        - end
        - 
        - struct QMpo <: AbstractTensorNetwork{Number}
        -     tensors::Dict{Site, Dict{Site, Tensor}}
        -     sites::Vector{Site}
        -     function QMpo(tensors::Dict{<:Site, <:Dict{<:Site, <:Tensor}})
        -         new(tensors, sort(collect(keys(tensors))))
        -     end
        - end
        - 
        - #TODO: rethink this function
        - function local_dims(mpo::QMpo, dir::Symbol)
        0     @assert dir ∈ (:down, :up)
        0     lds = Dict{Site, Int}()
        0     for site ∈ mpo.sites
     1584         mkeys = sort(collect(keys(mpo[site])))
     2016         if any(length(size(mpo[site][k])) > 2 for k ∈ mkeys)
        0             if dir == :down
      256                 ss = size(mpo[site][last(mkeys)])
      256                 push!(lds, site => length(ss) == 4 ? ss[4] : ss[2])
        -             else
        0                 ss = size(mpo[site][first(mkeys)])
        0                 push!(lds, site => length(ss) == 4 ? ss[2] : ss[1])
        -             end
        -         end
        -     end
        0     lds
        - end
        - 
        - function IdentityQMps(loc_dims::Dict, Dmax::Int=1)
        0     id = Dict{Site, Tensor}(site => zeros(Dmax, ld, Dmax) for (site, ld) ∈ loc_dims)
        0     site, ld = minimum(loc_dims)
       64     id[site] = zeros(1, ld, Dmax)
        0     site, ld = maximum(loc_dims)
       64     id[site] = zeros(Dmax, ld, 1)
      128     for (site, ld) ∈ loc_dims id[site][1, :, 1] .= 1 / sqrt(ld) end
      192     QMps(id)
        - end
        - 
        - @inline Base.size(tens::AbstractSparseTensor) = maximum.(tens.projs)
        - @inline function Base.setindex!(
        -     ket::AbstractTensorNetwork, A::AbstractArray, i::Site
        - )
        0     ket.tensors[i] = A
        - end
        - 
        - QMps(ϕ::AbstractMPS) = QMps(Dict(i => A for (i, A) ∈ enumerate(ϕ)))
        - QMpo(ϕ::AbstractMPO) = QMpo(Dict(i => Dict(0 => A) for (i, A) ∈ enumerate(ϕ)))
