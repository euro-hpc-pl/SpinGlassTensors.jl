        - export
        -     compress!,
        -     _left_nbrs_site,
        -     _right_nbrs_site,
        -     compress_twosite!,
        -     Environment,
        -     optimize_gauges_for_overlaps!!
        - mutable struct Environment <: AbstractEnvironment
        -     bra::QMps  # to be optimized
        -     mpo::QMpo
        -     ket::QMps
        -     trans::Symbol
        -     env::Dict
        - 
        -     function Environment(
        -         bra::QMps,
        -         mpo::QMpo,
        -         ket::QMps,
        -         trans::Symbol=:n
        -     )
        0         @assert trans ∈ (:n, :c)
        0         @assert bra.sites == ket.sites
        0         @assert issubset(bra.sites, mpo.sites)
        - 
     2240         env0 = Dict(
        -             (first(bra.sites), :left) => ones(1, 1, 1),
        -             (last(bra.sites), :right) => ones(1, 1, 1)
        -         )
      560         env = new(bra, mpo, ket, trans, env0)
        0         for site ∈ env.bra.sites update_env_left!(env, site, trans) end
        0         env
        -     end
        - end
        - 
        - function SpinGlassTensors.compress!(
        -     bra::QMps,
        -     mpo::QMpo,
        -     ket::QMps,
        -     Dcut::Int,
        -     tol::Real=1E-8,
        -     max_sweeps::Int=4,
        -     trans::Symbol=:n,
        -     args...
        - )
        0     env = Environment(bra, mpo, ket, trans)
        0     overlap = Inf
        0     overlap_before = measure_env(env, last(env.bra.sites), trans)
        - 
        0     for sweep ∈ 1:max_sweeps
        0         _left_sweep_var!(env, trans, args...)
        0         _right_sweep_var!(env, trans, args...)
        - 
        0         overlap = measure_env(env, last(env.bra.sites), trans)
      336         Δ = abs(overlap_before - abs(overlap))
        0         @info "Convergence" Δ
        - 
       96         if Δ < tol
        0             @info "Finished in $sweep sweeps of $(max_sweeps)."
        0             return overlap
        -         else
        0             overlap_before = overlap
        -         end
        -     end
        0     overlap
        - end
        - 
        - # doesn't work
        - function compress_twosite!(
        -     bra::QMps, mpo::QMpo, ket::QMps, Dcut::Int, tol::Real=1E-8, max_sweeps::Int=4, args...
        - )
        -     env = Environment(bra, mpo, ket)
        -     overlap = Inf
        -     overlap_before = measure_env(env, last(env.bra.sites))
        -     for sweep ∈ 1:max_sweeps
        -         _left_sweep_var_twosite!(env, Dcut, tol, args...)
        -         _right_sweep_var_twosite!(env, Dcut, tol, args...)
        - 
        -         overlap = measure_env(env, last(env.bra.sites))
        - 
        -         Δ = abs(overlap_before - abs(overlap))
        -         @info "Convergence" Δ
        - 
        -         if Δ < tol
        -             @info "Finished in $sweep sweeps of $(max_sweeps)."
        -             return overlap
        -         else
        -             overlap_before = overlap
        -         end
        -     end
        -     overlap
        - end
        - 
        - function _left_sweep_var!(env::Environment, trans::Symbol=:n, args...)
        0     for site ∈ reverse(env.bra.sites)
        0         update_env_right!(env, site, trans)
        0         A = project_ket_on_bra(env, site, trans)
     5376         @cast B[x, (y, z)] := A[x, y, z]
     2688         _, Q = rq_fact(B, args...)
     9024         @cast C[x, σ, y] := Q[x, (σ, y)] (σ ∈ 1:size(A, 2))
     1792         env.bra[site] = C
        0         clear_env_containing_site!(env, site)
        -     end
        - end
        - 
        - function _right_sweep_var!(env::Environment, trans::Symbol=:n, args...)
        0     for site ∈ env.bra.sites
        0         update_env_left!(env, site, trans)
        0         A = project_ket_on_bra(env, site, trans)
     5376         @cast B[(x, y), z] := A[x, y, z]
     1792         Q, _ = qr_fact(B, args...)
     5440         @cast C[x, σ, y] := Q[(x, σ), y] (σ ∈ 1:size(A, 2))
     1792         env.bra[site] = C
        0         clear_env_containing_site!(env, site)
        -     end
        - end
        - 
        - #TODO: to be changed
        - function _left_sweep_var_twosite!(env::Environment, Dcut::Int, tol::Number, args...)
        -     for site ∈ reverse(env.bra.sites[2:end])
        -         update_env_right!(env, site)
        -         A = project_ket_on_bra_twosite(env, site)
        -         @cast B[(x, y), (z, w)] := A[x, y, z, w]
        -         U, S, VV = svd(B, Dcut, tol, args...)
        -         V = VV'
        -         @cast C[x, σ, y] := V[x, (σ, y)] (σ ∈ 1:size(A, 3))
        -         env.bra[site] = C
        -         clear_env_containing_site!(env, site)
        -         if site == env.bra.sites[2]
        -             UU = U .* reshape(S, 1, :)
        -             @cast US[x, σ, y] := UU[(x, σ), y] (σ ∈ 1:size(A, 2))
        -             env.bra[env.bra.sites[1]] = US/norm(US)
        -             update_env_right!(env, env.bra.sites[2])
        -             update_env_right!(env, env.bra.sites[1])
        -         end
        -     end
        - end
        - 
        - #TODO: to be changed
        - function _right_sweep_var_twosite!(env::Environment, Dcut::Int, tol::Number, args...)
        -     for site ∈ env.bra.sites[1:end-1]
        -         site_r = _right_nbrs_site(site, env.bra.sites)
        -         update_env_left!(env, site)
        -         A = project_ket_on_bra_twosite(env, site_r)
        -         @cast B[(x, y), (z, w)] := A[x, y, z, w]
        -         U, S, V = svd(B, Dcut, tol, args...)
        -         @cast C[x, σ, y] := U[(x, σ), y] (σ ∈ 1:size(A, 2))
        -         env.bra[site] = C
        -         clear_env_containing_site!(env, site)
        -         if site_r == env.bra.sites[end]
        -             SV = S .* V'
        -             @cast SS[x, σ, y] := SV[x, (σ, y)] (σ ∈ 1:size(A, 3))
        -             env.bra[site_r] = SS ./ norm(SS)
        -             update_env_left!(env, site)
        -             update_env_left!(env, site_r)
        -         end
        -     end
        - end
        - 
        - "Largest x in sites: x < site"
        - function _left_nbrs_site(site::Site, sites)
        -     ls = filter(i -> i < site, sites)
        -     if isempty(ls) return -Inf end
        -     maximum(ls)
        - end
        - 
        - "Smallest x in sites: x > site"
        - function _right_nbrs_site(site::Site, sites)
        -     ms = filter(i -> i > site, sites)
        -     if isempty(ms) return Inf end
        -     minimum(ms)
        - end
        - 
        - function update_env_left!(env::Environment, site::Site, trans::Symbol=:n)
        0     if site <= first(env.bra.sites) return end
        - 
        0     ls = _left_nbrs_site(site, env.bra.sites)
     3136     LL = update_env_left(env.env[(ls, :left)], env.bra[ls], env.mpo[ls], env.ket[ls], trans)
        - 
        0     rs = _right_nbrs_site(ls, env.mpo.sites)
        0     while rs < site
        0         LL = update_env_left(LL, env.mpo[rs], Val(trans))
        0         rs = _right_nbrs_site(rs, env.mpo.sites)
        -     end
     6272     push!(env.env, (site, :left) => LL)
        - end
        - 
        - function update_env_right!(env::Environment, site::Site, trans::Symbol=:n)
        0     if site >= last(env.bra.sites) return end
        - 
        0     rs = _right_nbrs_site(site, env.bra.sites)
     1568     RR = update_env_right(env.env[(rs, :right)], env.bra[rs], env.mpo[rs], env.ket[rs], trans)
        - 
        0     ls = _left_nbrs_site(rs, env.mpo.sites)
        0     while ls > site
        0         RR = update_env_right(RR, env.mpo[ls], Val(trans))
        0         ls = _left_nbrs_site(ls, env.mpo.sites)
        -     end
     3136     push!(env.env, (site, :right) => RR)
        - end
        - 
        - function clear_env_containing_site!(env::Environment, site::Site)
     3808     delete!(env.env, (_left_nbrs_site(site, env.ket.sites), :right))
     3808     delete!(env.env, (_right_nbrs_site(site, env.ket.sites), :left))
        - end
        - 
        - #        -- A --
        - #      |    |
        - # L = LE -- M --
        - #      |    |
        - #        -- B --
        - function update_env_left(
        -     LE::S, A₀::S, M::T, B₀::S, trans::Symbol=:n
        - ) where {S <: AbstractArray{Float64, 3}, T <: AbstractDict}
    14336     sites = sort(collect(keys(M)))
        0     A = _update_tensor_forward(A₀, M, sites, Val(trans))
        0     B = _update_tensor_backwards(B₀, M, sites, Val(trans))
        0     update_env_left(LE, A, M[0], B, Val(trans))
        - end
        - 
        - function update_env_left(
        -     LE::S, M::T, ::Val{:n}
        - ) where {S <: AbstractArray{Float64, 3}, T <: AbstractDict}
        0     MM = M[0]  # Can be more general
        0     @tensor L[nt, nc, nb] :=  LE[nt, oc, nb] * MM[oc, nc]
        0     L
        - end
        - 
        - function update_env_left(
        -     LE::S, M::T, ::Val{:c}
        - ) where {S <: AbstractArray{Float64, 3}, T <: AbstractDict}
        -     MM = M[0]  # Can be more general
        -     @tensor L[nt, nc, nb] :=  LE[nt, oc, nb] * MM[oc, nc]
        -     L
        - end
        - 
        - function update_env_left(
        -     LE::S, A::S, M::T, B::S, ::Val{:n}
        - ) where {S <: AbstractArray{Float64, 3}, T <: AbstractArray{Float64, 4}}
  8032128     @tensor L[nb, nc, nt] := LE[ob, oc, ot] * A[ot, α, nt] *
        -                              M[oc, α, nc, β] * B[ob, β, nb] order = (ot, α, oc, β, ob)
        0     L
        - end
        - 
        - function update_env_left(
        -     LE::S, A::S, M::T, B::S, ::Val{:c}
        - ) where {S <: AbstractArray{Float64, 3}, T <: AbstractArray{Float64, 4}}
        -     @tensor L[nb, nc, nt] := LE[ob, oc, ot] * A[ot, α, nt] *
        -                              M[oc, β, nc, α] * B[ob, β, nb] order = (ot, α, oc, β, ob)
        -     L
        - end
        - 
        - # Improve this function with brodcasting
        - function update_env_left(
        -     LE::S, A::S, M::T, B::S, ::Val{:n}
        - ) where {S <: AbstractArray{Float64, 3}, T <: SparseSiteTensor}
        0     L = zeros(size(B, 3), maximum(M.projs[3]), size(A, 3))
        0     for (σ, lexp) ∈ enumerate(M.loc_exp)
        0         AA = @view A[:, M.projs[2][σ], :]
        0         LL = @view LE[:, M.projs[1][σ], :]
        0         BB = @view B[:, M.projs[4][σ], :]
        0         L[:, M.projs[3][σ], :] += lexp .* (BB' * LL * AA)
        -     end
        0     L
        - end
        - 
        - function update_env_left(
        -     LE::S, A::S, M::T, B::S, ::Val{:c}
        - ) where {S <: AbstractArray{Float64, 3}, T <: SparseSiteTensor}
        0     L = zeros(size(B, 3), maximum(M.projs[3]), size(A, 3))
        - 
        0     for (σ, lexp) ∈ enumerate(M.loc_exp)
        0         AA = @view A[:, M.projs[4][σ], :]
        0         LL = @view LE[:, M.projs[1][σ], :]
        0         BB = @view B[:, M.projs[2][σ], :]
        0         L[:, M.projs[3][σ], :] += lexp .* (BB' * LL * AA)
        -     end
        0     L
        - end
        - 
        - # TODO: TikZ picture to be added
        - # This is not optimal
        - function update_env_left(
        -     LE::S, A::S, M::T, B::S, ::Val{:n}
        - ) where {S <: AbstractArray{Float64, 3}, T <: SparseVirtualTensor}
        0     h = M.con
        0     p_lb, p_l, p_lt, p_rb, p_r, p_rt = M.projs
        - 
        0     @cast A4[x, k, l, y] := A[x, (k, l), y] (k ∈ 1:maximum(p_rt))
        0     @cast B4[x, k, l, y] := B[x, (k, l), y] (k ∈ 1:maximum(p_lb))
        - 
        0     L = zeros(size(B, 3), length(p_r), size(A, 3))
        0     for l ∈ 1:length(p_l), r ∈ 1:length(p_r)
        0         AA = @view A4[:, p_rt[r], p_lt[l], :]
        0         LL = @view LE[:, l, :]
        0         BB = @view B4[:, p_lb[l], p_rb[r], :]
        0         L[:, r, :] += h[p_l[l], p_r[r]] .* (BB' * LL * AA)
        -     end
        0     L
        - end
        - 
        - # TODO: TikZ picture to be added
        - function update_env_left(
        -     LE::S, A::S, M::T, B::S, ::Val{:c}
        - ) where {S <: AbstractArray{Float64, 3}, T <: SparseVirtualTensor}
        0     h = M.con
        0     p_lb, p_l, p_lt, p_rb, p_r, p_rt = M.projs
        - 
        0     @cast A4[x, k, l, y] := A[x, (k, l), y] (k ∈ 1:maximum(p_rt))
        0     @cast B4[x, k, l, y] := B[x, (k, l), y] (k ∈ 1:maximum(p_lb))
        - 
        0     L = zeros(size(B, 3), length(p_r), size(A, 3))
        0     for l ∈ 1:length(p_l), r ∈ 1:length(p_r)
        0         AA = @view A4[:, p_lb[l], p_rb[r], :]
        0         LL = @view LE[:, l, :]
        0         BB = @view B4[:, p_rt[r], p_lt[l], :]
        0         L[:, r, :] += h[p_l[l], p_r[r]] .* (BB' * LL * AA)
        -     end
        0     L
        - end
        - 
        - function _update_tensor_forward(
        -     A::S, M::T, sites, ::Val{:n}
        - ) where {S <: AbstractArray{Float64, 3}, T <: AbstractDict}
 12470528     B = copy(A)
        0     for i ∈ sites
        0         if i == 0 break end
        0         C = M[i]
        0         @tensor B[l, x, r] := B[l, y, r] * C[y, x]
        -     end
        0     B
        - end
        - 
        - function _update_tensor_forward(
        -     A::S, M::T, sites, ::Val{:c}
        - ) where {S <: AbstractArray{Float64, 3}, T <: AbstractDict}
        0     B = copy(A)
        0     for i ∈ reverse(sites)
        0         if i == 0 break end
        0         C = M[i]
        0         @tensor B[l, x, r] := B[l, y, r] * C[x, y]
        -     end
        0     B
        - end
        - 
        - function _update_tensor_backwards(
        -     A::S, M::T, sites, ::Val{:n}
        - ) where {S <: AbstractArray{Float64, 3}, T <: AbstractDict}
 10493888     B = copy(A)
        0     for i ∈ reverse(sites)
        0         if i == 0 break end
        0         C = M[i]
        0         @tensor B[l, x, r] := B[l, y, r] * C[x, y]
        -     end
        0     B
        - end
        - 
        - function _update_tensor_backwards(
        -     A::S, M::T, sites, ::Val{:c}
        - ) where {S <: AbstractArray{Float64, 3}, T <: AbstractDict}
        0     B = copy(A)
        0     for i ∈ sites
        0         if i == 0 break end
        0         C = M[i]
        0         @tensor B[l, x, r] := B[l, y, r] * C[y, x]
        -     end
        0     B
        - end
        - 
        - #      -- A --
        - #         |    |
        - # R =  -- M -- RE
        - #         |    |
        - #      -- B --
        - function update_env_right(
        -     RE::S, A::S, M::T, B::S, ::Val{:n}
        - ) where {T <: AbstractArray{Float64, 4}, S <: AbstractArray{Float64, 3}}
  4015616     @tensor R[nt, nc, nb] := RE[ot, oc, ob] * A[nt, α, ot] *
        -                              M[nc, α, oc, β] * B[nb, β, ob] order = (ot, α, oc, β, ob)
        0     R
        - end
        - 
        - function update_env_right(
        -     RE::S, A::S, M::T, B::S, ::Val{:c}
        - ) where {T <: AbstractArray{Float64, 4}, S <: AbstractArray{Float64, 3}}
        -     @tensor R[nt, nc, nb] := RE[ot, oc, ob] * A[nt, α, ot] *
        -                              M[nc, β, oc, α] * B[nb, β, ob] order = (ot, α, oc, β, ob)
        -     R
        - end
        - 
        - #TODO: think of doing threading over σ
        - function update_env_right(
        -     RE::S, A::S, M::T, B::S, ::Val{:n}
        - ) where {T <: SparseSiteTensor, S <: AbstractArray{Float64, 3}}
        0     R = zeros(size(A, 1), maximum(M.projs[1]), size(B, 1))
        - 
        -     #Threads.@threads for σ ∈ 1:length(M.loc_exp)
        -     #    lexp = M.loc_exp[σ]
        0     for (σ, lexp) ∈ enumerate(M.loc_exp)
        0         AA = @view A[:, M.projs[2][σ], :]
        0         RR = @view RE[:, M.projs[3][σ], :]
        0         BB = @view B[:, M.projs[4][σ], :]
        0         R[:, M.projs[1][σ], :] += lexp .* (AA * RR * BB')
        -     end
        0     R
        - end
        - 
        - #TODO: think of doing threading over σ
        - function update_env_right(
        -     RE::S, A::S, M::T, B::S, ::Val{:c}
        - ) where {T <: SparseSiteTensor, S <: AbstractArray{Float64, 3}}
        0     R = zeros(size(A, 1), maximum(M.projs[1]), size(B, 1))
        - 
        -     #Threads.@threads for σ ∈ 1:length(M.loc_exp)
        -     #    lexp = M.loc_exp[σ]
        0     for (σ, lexp) ∈ enumerate(M.loc_exp)
        0         AA = @view A[:, M.projs[4][σ], :]
        0         RR = @view RE[:, M.projs[3][σ], :]
        0         BB = @view B[:, M.projs[2][σ], :]
        0         R[:, M.projs[1][σ], :] += lexp .* (AA * RR * BB')
        -     end
        0     R
        - end
        - 
        - # TODO: TikZ picture to be added
        - function update_env_right(
        -     RE::S, A::S, M::T, B::S, ::Val{:n}
        - ) where {T <: SparseVirtualTensor, S <: AbstractArray{Float64,3}}
        0     h = M.con
        0     p_lb, p_l, p_lt, p_rb, p_r, p_rt = M.projs
        0     @cast A4[x, k, l, y] := A[x, (k, l), y] (k ∈ 1:maximum(p_rt))
        0     @cast B4[x, k, l, y] := B[x, (k, l), y] (k ∈ 1:maximum(p_lb))
        - 
        0     R = zeros(size(A, 1), length(p_l), size(B, 1))
        0     for l ∈ 1:length(p_l), r ∈ 1:length(p_r)
        0         AA = @view A4[:, p_rt[r], p_lt[l], :]
        0         RR = @view RE[:, r, :]
        0         BB = @view B4[:, p_lb[l], p_rb[r], :]
        0         R[:, l, :] += h[p_l[l], p_r[r]] * (AA * RR * BB')
        -     end
        0     R
        - end
        - 
        - # TODO: TikZ picture to be added
        - function update_env_right(
        -     RE::S, A::S, M::T, B::S, ::Val{:c}
        - ) where {T <: SparseVirtualTensor, S <: AbstractArray{Float64, 3}}
        0     h = M.con
        0     p_lb, p_l, p_lt, p_rb, p_r, p_rt = M.projs
        0     @cast A4[x, k, l, y] := A[x, (k, l), y] (k ∈ 1:maximum(p_rt))
        0     @cast B4[x, k, l, y] := B[x, (k, l), y] (k ∈ 1:maximum(p_lb))
        - 
        0     R = zeros(size(A, 1), length(p_l), size(B, 1))
        0     for l ∈ 1:length(p_l), r ∈ 1:length(p_r)
        0         AA = @view A4[:, p_lb[l], p_rb[r], :]
        0         RR = @view RE[:, r, :]
        0         BB = @view B4[:, p_rt[r], p_lt[l], :]
        0         R[:, l, :] += h[p_l[l], p_r[r]] * (AA * RR * BB')
        -     end
        0     R
        - end
        - 
        - function update_env_right(
        -     RE::S, A₀::S1, M::T, B₀::S, trans::Symbol=:n
        - ) where {T <: AbstractDict, S <: AbstractArray{Float64, 3}, S1 <: AbstractArray{Float64, 3}}
     6272     sites = sort(collect(keys(M)))
        0     A = _update_tensor_forward(A₀, M, sites, Val(trans))
        0     B = _update_tensor_backwards(B₀, M, sites, Val(trans))
        0     update_env_right(RE, A, M[0], B, Val(trans))
        - end
        - 
        - #           --
        - #              |
        - # R =  -- M -- RE
        - #              |
        - #           --
        - function update_env_right(
        -     RE::S, M::T, ::Val{:c}
        - ) where {S <: AbstractArray{Float64, 3}, T <: AbstractDict}
        -     MM = M[0]
        -     @tensor R[nt, nc, nb] := MM[nc, oc] * RE[nt, oc, nb]
        -     R
        - end
        - 
        - function update_env_right(
        -     RE::S, M::T, ::Val{:n}
        - ) where {S <: AbstractArray{Float64, 3}, T <: AbstractDict}
        0     MM = M[0]
        0     @tensor R[nt, nc, nb] := MM[nc, oc] * RE[nt, oc, nb]
        0     R
        - end
        - 
        - function project_ket_on_bra(env::Environment, site::Site, trans::Symbol=:n)
     7168     project_ket_on_bra(
        -         env.env[(site, :left)],
        -         env.ket[site],
        -         env.mpo[site],
        -         env.env[(site, :right)],
        -         Val(trans)
        -     )
        - end
        - 
        - function project_ket_on_bra_twosite(env::Environment, site::Site)
        -     site_l = _left_nbrs_site(site, env.bra.sites)
        -     project_ket_on_bra(
        -         env.env[(site_l, :left)],
        -         env.ket[site_l],
        -         env.ket[site],
        -         env.mpo[site_l][0],
        -         env.mpo[site][0],
        -         env.env[(site, :right)]
        -     )
        - end
        - 
        - 
        - #   |    |    |
        - #  LE -- M -- RE
        - #   |    |    |
        - #     -- B --
        - function project_ket_on_bra(
        -     LE::S, B::S, M::T, RE::S, ::Val{:n}
        - ) where {T <: AbstractArray{Float64, 4}, S <: AbstractArray{Float64, 3}}
  8323840     @tensor A[x, y, z] := LE[k, l, x] * B[k, m, o] *
        -                           M[l, y, n, m] * RE[z, n, o] order = (k, l, m, n, o)
        0     A
        - end
        - 
        - function project_ket_on_bra(
        -     LE::S, B::S, C::S, M::T, N::T, RE::S, ::Val{:n}
        - ) where {T <: AbstractArray{Float64, 4}, S <: AbstractArray{Float64, 3}}
        -     @tensor A[x, y, z, r] := LE[k, l, x] * B[k, m, o] *
        -                           M[l, y, n, m] * C[o, s, q] *
        -                           N[n, z, p, s] * RE[r, p, q] order = (k, l, m, n, o, s, p, q)
        -     A
        - end
        - 
        - function project_ket_on_bra(
        -     LE::S, B::S, M::T, RE::S, ::Val{:n}
        - ) where {T <: AbstractArray{Float64, 2}, S <: AbstractArray{Float64, 3}}
  7005696     @tensor A[x, y, z] := B[x, a, z] * M[y, a]
        0     A
        - end
        - 
        - function project_ket_on_bra(
        -     LE::S, B::S, M::T, RE::S, ::Val{:c}
        - ) where {T <: AbstractArray{Float64, 2}, S <: AbstractArray{Float64, 3}}
        -     @tensor A[x, y, z] := B[x, a, z] * M[a, y]
        -     A
        - end
        - 
        - #TODO: think of threading over σ
        - function project_ket_on_bra(
        -     LE::S, B::S, M::T, RE::S, ::Val{:n}
        - ) where {S <: AbstractArray{Float64, 3}, T <: SparseSiteTensor}
        0     A = zeros(size(LE, 3), maximum(M.projs[2]), size(RE, 1))
        - 
        -     #Threads.@threads for σ ∈ 1:length(M.loc_exp)
        -     #    lexp = M.loc_exp[σ]
        0     for (σ, lexp) ∈ enumerate(M.loc_exp)
        0         le = @view LE[:, M.projs[1][σ], :]
        0         b = @view B[:, M.projs[4][σ], :]
        0         re = @view RE[:, M.projs[3][σ], :]
        0         A[:, M.projs[2][σ], :] += lexp .* (le' * b * re')
        -     end
        0     A
        - end
        - 
        - function project_ket_on_bra(
        -     LE::S, B::S, M::T, RE::S, ::Val{:n}
        - ) where {S <: AbstractArray{Float64, 3}, T <: SparseVirtualTensor}
        - 
        0     h = M.con
        0     p_lb, p_l, p_lt, p_rb, p_r, p_rt = M.projs
        0     @cast B4[x, k, l, y] := B[x, (k, l), y] (k ∈ 1:maximum(p_lb))
        0     A = zeros(size(LE, 3), maximum(p_rt), maximum(p_lt), size(RE, 1))
        0     for l ∈ 1:length(p_l), r ∈ 1:length(p_r)
        0         le = @view LE[:, l, :]
        0         b = @view B4[:, p_lb[l], p_rb[r], :]
        0         re = @view RE[:, r, :]
        0         A[:,  p_rt[r], p_lt[l], :] += h[p_l[l], p_r[r]] .* (le' * b * re')
        -     end
        0     @cast AA[l, (ũ, u), r] := A[l, ũ, u, r]
        0     AA
        - end
        - 
        - function project_ket_on_bra(
        -     LE::S, B::S, M::T, RE::S, ::Val{:c}
        - ) where {T <: AbstractArray{Float64, 4}, S <: AbstractArray{Float64, 3}}
        -     @tensor A[x, y, z] := LE[k, l, x] * B[k, m, o] *
        -                           M[l, m, n, y] * RE[z, n, o] order = (k, l, m, n, o)
        -     A
        - end
        - 
        - function project_ket_on_bra(
        -     LE::S, B::S, C::S, M::T, N::T, RE::S, ::Val{:c}
        - ) where {T <: AbstractArray{Float64, 4}, S <: AbstractArray{Float64, 3}}
        -     @tensor A[x, m, s, r] := LE[k, l, x] * B[k, y, o] *
        -                           M[l, y, n, m] * C[o, z, q] *
        -                           N[n, z, p, s] * RE[r, p, q] order = (k, l, y, n, o, z, p, q)
        -     A
        - end
        - #=
        - function project_ket_on_bra(
        -     LE::S, B::S, C::S, M::T, N::T, RE::S, ::Val{:c}
        - ) where {T <: AbstractArray{Float64, 4}, S <: AbstractArray{Float64, 3}}
        -     @tensor A[x, y, z, r] := LE[k, l, x] * B[k, m, o] *
        -                           M[l, y, n, m] * C[o, s, q] *
        -                           N[n, z, p, s] * RE[r, p, q] order = (k, l, m, n, o, s, p, q)
        -     A
        - end
        - =#
        - #TODO: think of threading over σ
        - function project_ket_on_bra(
        -     LE::S, B::S, M::T, RE::S, ::Val{:c}
        - ) where {S <: AbstractArray{Float64, 3}, T <: SparseSiteTensor}
        -     A = zeros(size(LE, 3), maximum(M.projs[4]), size(RE, 1))
        - 
        -     #Threads.@threads for σ ∈ 1:length(M.loc_exp)
        -     #    lexp = M.loc_exp[σ]
        -     for (σ, lexp) ∈ enumerate(M.loc_exp)
        -         le = @view LE[:, M.projs[1][σ], :]
        -         b = @view B[:, M.projs[2][σ], :]
        -         re = @view RE[:, M.projs[3][σ], :]
        -         A[:, M.projs[4][σ], :] += lexp .* (le' * b * re')
        -     end
        -     A
        - end
        - 
        - function project_ket_on_bra(
        -     LE::S, B::S, M::T, RE::S, ::Val{:c}
        - ) where {S <: AbstractArray{Float64, 3}, T <: SparseVirtualTensor}
        -     h = M.con
        -     p_lb, p_l, p_lt, p_rb, p_r, p_rt = M.projs
        -     @cast B4[x, k, l, y] := B[x, (k, l), y] (k ∈ 1:maximum(p_lb))
        -     A = zeros(size(LE, 3), maximum(p_lb), maximum(p_rb), size(RE, 1))
        -     for l ∈ 1:length(p_l), r ∈ 1:length(p_r)
        -         le = @view LE[:, l, :]
        -         b = @view B4[:, p_rt[r], p_lt[l], :]
        -         re = @view RE[:, r, :]
        -         A[:, p_lb[l], p_rb[r], :] += h[p_l[l], p_r[r]] .* (le' * b * re')
        -     end
        -     @cast AA[l, (ũ, u), r] := A[l, ũ, u, r]
        -     AA
        - end
        - 
        - function project_ket_on_bra(
        -     LE::S, B₀::S, M::T, RE::S, ::Val{:n}
        - ) where {S <: AbstractArray{Float64, 3}, T <: AbstractDict}
    14336     sites = sort(collect(keys(M)))
    50176     C = sort(collect(M), by = x -> x[1])
        -     TT = B₀
        0     for (t, v) ∈ reverse(C) TT = project_ket_on_bra(LE, TT, v, RE, Val(:n)) end
        0     TT
        - end
        - 
        - function project_ket_on_bra(
        -     LE::S, B₀::S, M::T, RE::S, ::Val{:c}
        - ) where {S <: AbstractArray{Float64, 3}, T <: AbstractDict}
        -     sites = sort(collect(keys(M)))
        -     C = sort(collect(M), by = x -> x[1])
        -     TT = B₀
        -     for (t, v) ∈ C TT = project_ket_on_bra(LE, TT, v, RE, Val(:c)) end
        -     TT
        - end
        - 
        - function measure_env(env::Environment, site::Site, trans::Symbol=:n)
      448     L = update_env_left(
        -         env.env[(site, :left)], env.bra[site], env.mpo[site], env.ket[site], trans
        -     )
      448     R = env.env[(site, :right)]
      224     @tensor L[t, c, b] * R[b, c, t]
        - end
        - 
        - function truncate!(ψ::QMps, s::Symbol, Dcut::Int=typemax(Int), args...)
        0     @assert s ∈ (:left, :right)
        0     if s == :right
        0         _right_sweep!(ψ, args...)
        0         _left_sweep!(ψ, Dcut, args...)
        -     else
        0         _left_sweep!(ψ, args...)
        0         _right_sweep!(ψ, Dcut, args...)
        -     end
        - end
        - canonise!(ψ::QMps, s::Symbol) = canonise!(ψ, Val(s))
        - canonise!(ψ::QMps, ::Val{:right}) = _left_sweep!(ψ, typemax(Int))
        - canonise!(ψ::QMps, ::Val{:left}) = _right_sweep!(ψ, typemax(Int))
        - 
        - function _right_sweep!(ψ::QMps, Dcut::Int=typemax(Int), args...)
        0     R = ones(eltype(ψ[1]), 1, 1)
        0     for i ∈ ψ.sites
        0         A = ψ[i]
    16128         @matmul M̃[(x, σ), y] := sum(α) R[x, α] * A[α, σ, y]
     1792         Q, R = qr_fact(M̃, Dcut, args...)
      896         R ./= maximum(abs.(R))
     5440         @cast A[x, σ, y] := Q[(x, σ), y] (σ ∈ 1:size(A, 2))
     1792         ψ[i] = A
        -     end
        - end
        - 
        - function _left_sweep!(ψ::QMps, Dcut::Int=typemax(Int), args...)
        0     R = ones(eltype(ψ[1]), 1, 1)
        0     for i ∈ reverse(ψ.sites)
        0         B = ψ[i]
    12544         @matmul M̃[x, (σ, y)] := sum(α) B[x, σ, α] * R[α, y]
     4432         R, Q = rq_fact(M̃, Dcut, args...)
      896         R ./= maximum(abs.(R))
     9536         @cast B[x, σ, y] := Q[x, (σ, y)] (σ ∈ 1:size(B, 2))
     1792         ψ[i] = B
        -     end
        - end
        - 
        - function _gauges_right_sweep!!!(ψ_top::QMps, ψ_bot::QMps, all_gauges::Dict)
        -     RT, RB = ones(1, 1), ones(1, 1)
        -     for i ∈ ψ_top.sites
        -         T, B = ψ_top[i], ψ_bot[i]
        - 
        -         @tensor T[a, b, c] := RT[a, s] * T[s, b, c]
        -         @tensor B[a, b, c] := RB[a, s] * B[s, b, c]
        -         @tensor ρ_t[r, s] := T[i, r, j] * conj(T)[i, s, j]
        -         @tensor ρ_b[r, s] := B[i, r, j] * conj(B)[i, s, j]
        - 
        -         gauge = (diag(ρ_b) ./ diag(ρ_t)) .^ (1 / 4) # optimize
        -         gauge_inv = 1.0 ./ gauge
        -         all_gauges[i] .*= gauge # update
        - 
        -         AT = T .* reshape(gauge, (1, :, 1))
        -         AB = B .* reshape(gauge_inv, (1, :, 1))
        - 
        -         @cast ATR[(x, σ), y] := AT[x, σ, y]
        -         QT, RT = qr_fact(ATR)
        -         RT ./= maximum(abs.(RT))
        -         @cast AT[x, σ, y] := QT[(x, σ), y] (σ ∈ 1:size(AT, 2))
        -         ψ_top[i] = AT
        - 
        -         @cast ABR[(x, σ), y] := AB[x, σ, y]
        -         QB, RB = qr_fact(ABR)
        -         RB ./= maximum(abs.(RB))
        -         @cast AB[x, σ, y] := QB[(x, σ), y] (σ ∈ 1:size(AB, 2))
        -         ψ_bot[i] = AB
        -     end
        - end
        - 
        - function _gauges_left_sweep!!!(ψ_top::QMps, ψ_bot::QMps, all_gauges::Dict)
        -     RT, RB = ones(1, 1), ones(1, 1)
        - 
        -     for i ∈ reverse(ψ_top.sites)
        -         T, B = ψ_top[i], ψ_bot[i]
        - 
        -         @tensor T[a, b, c] := T[a, b, s] * RT[s, c]
        -         @tensor B[a, b, c] := B[a, b, s] * RB[s, c]
        -         @tensor ρ_t[r, s] := T[i, r, j] * conj(T)[i, s, j]
        -         @tensor ρ_b[r, s] := B[i, r, j] * conj(B)[i, s, j]
        - 
        -         gauge = (diag(ρ_b) ./ diag(ρ_t)) .^ (1 / 4) # optimize
        -         gauge_inv = 1.0 ./ gauge
        -         all_gauges[i] .*= gauge # update
        - 
        -         AT = T .* reshape(gauge, (1, :, 1))
        -         AB = B .* reshape(gauge_inv, (1, :, 1))
        - 
        -         @cast ATR[x, (σ, y)] := AT[x, σ, y]
        -         RT, QT = rq_fact(ATR)
        -         RT ./= maximum(abs.(RT))
        -         @cast AT[x, σ, y] := QT[x, (σ, y)] (σ ∈ 1:size(AT, 2))
        -         ψ_top[i] = AT
        - 
        -         @cast ABR[x, (σ, y)] := AB[x, σ, y]
        -         RB, QB = rq_fact(ABR)
        -         RB ./= maximum(abs.(RB))
        -         @cast AB[x, σ, y] := QB[x, (σ, y)] (σ ∈ 1:size(AB, 2))
        -         ψ_bot[i] = AB
        -     end
        - end
        - 
        - function optimize_gauges_for_overlaps!!(
        -     ψ_top::QMps,
        -     ψ_bot::QMps,
        -     tol::Real=1E-8,
        -     max_sweeps::Int=4
        - )
        -     canonise!(ψ_top, :right)
        -     canonise!(ψ_bot, :right)
        - 
        -     overlap_old = dot(ψ_top, ψ_bot)
        -     all_gauges = Dict(i => ones(size(ψ_top[i], 2)) for i ∈ ψ_top.sites)
        -     for _ ∈ 1:max_sweeps
        -         _gauges_right_sweep!!!(ψ_top, ψ_bot, all_gauges)
        -         _gauges_left_sweep!!!(ψ_top, ψ_bot, all_gauges)
        - 
        -         overlap_new = dot(ψ_top, ψ_bot)
        -         Δ = overlap_new / overlap_old
        -         overlap_old = overlap_new
        -         if abs(Δ - 1.0) < tol break end
        -     end
        -     all_gauges
        - end
